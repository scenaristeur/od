{"version":3,"file":"js/949.653f9732.js","mappings":"sFAAA,IAAIA,EAAyB,qBAAXC,OAAyBA,OAAOD,IAAME,EAAQ,MAChEF,EAAIG,MAAMC,MAAQF,EAAQ,MAE1BF,EAAIG,MAAME,KAAO,SAASC,EAAIC,EAAKC,GAElC,OADCD,EAAMA,GAAO,CAAC,GAAGE,KAAM,EACjBC,KAAKN,KAAKE,EAAIC,EAAKC,EAC1B,C,uCCND,IAAIR,EAAyB,qBAAXC,OAAyBA,OAAOD,IAAME,EAAQ,MAEhEF,EAAIG,MAAMC,KAAO,SAASE,EAAIC,EAAKC,EAAIG,GAatC,OAZAA,EAAQA,GAAS,EACjBJ,EAAMA,GAAO,CAAC,EACdA,EAAIK,IAAML,EAAIK,KAAO,CAAC,EACtBL,EAAIM,IAAMN,EAAIM,KAAO,CAAC,EACtBN,EAAIO,IAAMP,EAAIO,KAAOR,EACrBC,EAAIQ,KAAOR,EAAIQ,OAAQ,EACvBR,EAAIS,IAAMT,EAAIS,KAAO,CAACP,IAAK,WAC1BQ,OAAOC,KAAKX,EAAIS,IAAIG,GAAGC,SAAQ,SAASC,EAAEC,IACtCA,EAAIf,EAAIS,IAAIG,EAAEE,KAAKC,EAAEb,KACxB,IACDF,EAAIS,IAAIG,EAAI,CAAC,CACb,EAAEA,EAAE,CAAC,GACCT,KAAKa,IAAG,SAASC,EAAMC,EAAKC,EAAKV,GAavC,GAZAW,aAAapB,EAAIqB,IACjBrB,EAAIqB,GAAKC,YAAW,WACftB,EAAIO,MACRP,EAAIO,IAAIgB,KAAKvB,EAAIC,GAAGuB,EAAGxB,EAAIK,IAAKL,EAAIkB,IAAKlB,EAAKA,EAAIS,KAC/CT,EAAIE,MACNF,EAAIS,IAAIP,MACRF,EAAIO,IAAM,MAEX,GAAEP,EAAIyB,MAAQ,GACfzB,EAAIC,GAAKD,EAAIC,IAAMkB,EACnBnB,EAAIkB,IAAMlB,EAAIkB,KAAOA,EACrBlB,EAAIS,IAAIG,EAAET,KAAKuB,EAAEC,IAAMlB,GACpB,IAAShB,EAAImC,MAAMX,GAAtB,CAQA,IAAIY,EAAM1B,KACVmB,WAAWQ,KAAKpB,OAAOC,KAAKM,IAAO,SAASC,EAAKa,GAChD,GAAG,MAAQb,GAAQlB,EAAIQ,KAAvB,CACAuB,EAAMd,EAAKC,GACX,IAAyBS,EAArBtB,EAAMJ,GAAMD,EAAIK,IAChBA,IACD,kBAAqBsB,EAAKlC,EAAImC,MAAMG,IAIpC/B,EAAIM,IAAIqB,GACVtB,EAAIa,GAAOlB,EAAIM,IAAIqB,GAGjB3B,EAAII,OAASA,EACfC,EAAIa,GAAOb,EAAIa,IAAQa,EAGxBF,EAAIG,IAAId,GAAKrB,KAAKG,EAAIO,IAAKP,EAAKA,EAAIM,IAAIqB,GAAMtB,EAAIa,GAAO,CAAC,EAAGd,EAAM,GAXlEC,EAAIa,GAAOa,EAL0B,CAiBtC,GApBA,MANI9B,EAGHA,EAAGiB,GAAOD,EAFVjB,EAAIK,IAAMY,CA0BZ,GACD,C","sources":["webpack://od/./node_modules/gun/lib/load.js","webpack://od/./node_modules/gun/lib/open.js"],"sourcesContent":["var Gun = (typeof window !== \"undefined\")? window.Gun : require('../gun');\nGun.chain.open || require('./open');\n\nGun.chain.load = function(cb, opt, at){\n\t(opt = opt || {}).off = !0;\n\treturn this.open(cb, opt, at);\n}","var Gun = (typeof window !== \"undefined\")? window.Gun : require('../gun');\n\nGun.chain.open = function(cb, opt, at, depth){ // this is a recursive function, BEWARE!\n\tdepth = depth || 1;\n\topt = opt || {}; // init top level options.\n\topt.doc = opt.doc || {};\n\topt.ids = opt.ids || {};\n\topt.any = opt.any || cb;\n\topt.meta = opt.meta || false;\n\topt.eve = opt.eve || {off: function(){ // collect all recursive events to unsubscribe to if needed.\n\t\tObject.keys(opt.eve.s).forEach(function(i,e){ // switch to CPU scheduled setTimeout.each?\n\t\t\tif(e = opt.eve.s[i]){ e.off() }\n\t\t});\n\t\topt.eve.s = {};\n\t}, s:{}}\n\treturn this.on(function(data, key, ctx, eve){ // subscribe to 1 deeper of data!\n\t\tclearTimeout(opt.to); // do not trigger callback if bunch of changes...\n\t\topt.to = setTimeout(function(){ // but schedule the callback to fire soon!\n\t\t\tif(!opt.any){ return }\n\t\t\topt.any.call(opt.at.$, opt.doc, opt.key, opt, opt.eve); // call it.\n\t\t\tif(opt.off){ // check for unsubscribing.\n\t\t\t\topt.eve.off();\n\t\t\t\topt.any = null;\n\t\t\t}\n\t\t}, opt.wait || 9);\n\t\topt.at = opt.at || ctx; // opt.at will always be the first context it finds.\n\t\topt.key = opt.key || key;\n\t\topt.eve.s[this._.id] = eve; // collect all the events together.\n\t\tif(true === Gun.valid(data)){ // if primitive value...\n\t\t\tif(!at){\n\t\t\t\topt.doc = data;\n\t\t\t} else {\n\t\t\t\tat[key] = data;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tvar tmp = this; // else if a sub-object, CPU schedule loop over properties to do recursion.\n\t\tsetTimeout.each(Object.keys(data), function(key, val){\n\t\t\tif('_' === key && !opt.meta){ return }\n\t\t\tval = data[key];\n\t\t\tvar doc = at || opt.doc, id; // first pass this becomes the root of open, then at is passed below, and will be the parent for each sub-document/object.\n\t\t\tif(!doc){ return } // if no \"parent\"\n\t\t\tif('string' !== typeof (id = Gun.valid(val))){ // if primitive...\n\t\t\t\tdoc[key] = val;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(opt.ids[id]){ // if we've already seen this sub-object/document\n\t\t\t\tdoc[key] = opt.ids[id]; // link to itself, our already in-memory one, not a new copy.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(opt.depth <= depth){ // stop recursive open at max depth.\n\t\t\t\tdoc[key] = doc[key] || val; // show link so app can load it if need.\n\t\t\t\treturn;\n\t\t\t} // now open up the recursion of sub-documents!\n\t\t\ttmp.get(key).open(opt.any, opt, opt.ids[id] = doc[key] = {}, depth+1); // 3rd param is now where we are \"at\".\n\t\t});\n\t})\n}"],"names":["Gun","window","require","chain","open","load","cb","opt","at","off","this","depth","doc","ids","any","meta","eve","Object","keys","s","forEach","i","e","on","data","key","ctx","clearTimeout","to","setTimeout","call","$","wait","_","id","valid","tmp","each","val","get"],"sourceRoot":""}